[{"categories":["typescript"],"content":"提取Promise的返回类型 1 2 export type PromiseReturnType\u003cT extends (...args: any) =\u003e any\u003e = ReturnType\u003cT\u003e extends Promise\u003cinfer R\u003e ? R : ReturnType\u003cT\u003e 1 2 3 4 5 6 7 8 type PromiseData = ()=\u003ePromise\u003c{ a: number b: string }\u003e type Foo = PromiseReturnType\u003cPromiseData\u003e // Foo = { a: number, b:string } 提取任意泛型的类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 响应结构 interface GlobalResponse\u003cT\u003e { code: StatusCode msg: string data: T } // 拿到 GlobalResponse 中的T的类型 type ApiResponseReturnType\u003cT\u003e = T extends GlobalResponse\u003cinfer U\u003e ? U : never // example type Foo = GlobalResponse\u003c{ foo: string bar: string }\u003e type Bar = ApiResponseReturnType\u003cFoo\u003e // Bar = {foo: string, bar: string} 提取对象路径 自己对vue-request 这个库做了一层封装，为了实现动态获取接口返回数据，需要根据返回类型生成字段路径，传入方法拿到数据。\n1 2 3 4 5 6 7 8 type NestedKeyOf\u003cObjectType extends object\u003e = { [Key in keyof ObjectType \u0026 (string | number)]: ObjectType[Key] extends unknown[] ? `${Key}` : ObjectType[Key] extends object ? `${Key}` | `${Key}.${NestedKeyOf\u003cObjectType[Key]\u003e}` : `${Key}` }[keyof ObjectType \u0026 (string | number)] 使用上述类型后，就可以根据返回类型拿到字段路径了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 全局响应结构 interface GlobalResponse\u003cT\u003e { code: StatusCode msg: string data: T } // 使用GlobalResponse重新组成返回类型 export type UseHttpDataSource\u003cT extends AnyFun\u003e = GlobalResponse\u003c ApiResponseReturnType\u003cPromiseReturnType\u003cT\u003e\u003e \u003e // 拿到 GlobalResponse 中的T的类型 export type ApiResponseReturnType\u003cT\u003e = T extends GlobalResponse\u003cinfer U\u003e ? U : never // 提取函数返回数据的对象路径联合类型 export type UseHttpDataSourceKeys\u003cT extends AnyFun\u003e = NestedKeyOf\u003c UseHttpDataSource\u003cT\u003e \u003e // 对axios的封装，这里不展示 const getData = (params: { name: string }) =\u003e request.get\u003c{ data: { list: string[] } }\u003e('/api/example', params) // useHttp内部对dataSourceKey定义为UseHttpDataSourceKeys const { run, data, // 经过dataSourceKey的处理，返回结果为string[] loading } = useHttp(getData, { defaultParams: [{ name: '' }], dataSourceKey: 'data.list', // 传入路径，在自己封装的useHttp中根据路径拿到数据 debounceInterval: 300 }) 由于做了类型定义，这里很容易得到编辑器提示 useHttp 放一份自己对vue-request封装的hook，仅作为参考，许多类型定义没有放出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 import { Ref, ref } from 'vue' import { PromiseReturnType, YxResponse, YxResponseReturnType } from '@/types/app' import { useRequest, Options } from 'vue-request' import { otherUtil } from '@/utils' export type UseHttpDataSourceKeys\u003cT extends AnyFun\u003e = NestedKeyOf\u003c UseHttpDataSource\u003cT\u003e \u003e export type UseHttpDataSource\u003cT extends AnyFun\u003e = YxResponse\u003c YxResponseReturnType\u003cPromiseReturnType\u003cT\u003e\u003e \u003e export type UseHttpDataType\u003cT extends AnyFun, K extends string\u003e = TypeFromPath\u003c UseHttpDataSource\u003cT\u003e, K \u003e export type UseHttpServiceParams\u003cT extends AnyFun\u003e = Parameters\u003cT\u003e type RequestOptions\u003c T extends AnyFun, K extends string, D extends unknown[] \u003e = Omit\u003c Options\u003cUseHttpDataType\u003cT, K\u003e, D\u003e, | 'onSuccess' | 'onBefore' | 'manual' | 'onError' | 'onAfter' | 'initialData' | 'ready' \u003e export type UseHttpOptions\u003c T extends AnyFun, K extends string, D extends UseHttpServiceParams\u003cT\u003e, C extends any[] \u003e = RequestOptions\u003cT, K, D\u003e \u0026 { manual?: boolean dataSourceKey?: K \u0026 UseHttpDataSourceKeys\u003cT\u003e onBefore?: ( ...params: ArrayConcat\u003cD, C\u003e ) =\u003e | [...UseHttpServiceParams\u003cT\u003e] | boolean | undefined | void | Promise\u003c[...UseHttpServiceParams\u003cT\u003e] | boolean\u003e onSuccess?: ( data: Ref\u003cUseHttpDataType\u003cT, K\u003e\u003e, params: ArrayConcat\u003cD, C\u003e ) =\u003e void onError?: (error: YxResponse\u003cany\u003e, ...params: ArrayConcat\u003cD, C\u003e) =\u003e void onAfter?: (...params: ArrayConcat\u003cD, C\u003e) =\u003e void onControl?: (params: D, ...controls: C) =\u003e [...UseHttpServiceParams\u003cT\u003e] initialData?: Partial\u003cUseHttpDataType\u003cT, K\u003e\u003e } type RequestReturnType = ReturnType\u003ctypeof useRequest\u003e export type UseHttpReturn\u003c T extends AnyFun, K extends string, D extends unknown[], C extends any[] \u003e = { runAsync: (...params: D) =\u003e Promise\u003cUseHttpDataSource\u003cT\u003e\u003e run: (...params: D) =\u003e void loading: RequestReturnType['loading'] error: RequestReturnType['error'] data: Ref\u003cUseHttpDataType\u003cT, K\u003e\u003e params: Ref\u003cnever[] | D\u003e refresh: () =\u003e void refreshAsync: () =\u003e Promise\u003cUseHttpDataSource\u003cT\u003e\u003e runWithControl: (...controls: C) =\u003e void runWithControlAsync: () =\u003e Promise\u003cUseHttpDataSource\u003cT\u003e\u003e } function useHttp\u003c T extends AnyFun, K extends UseHttpDataSourceKeys\u003cT\u003e, D extends UseHttpServiceParams\u003cT\u003e, C extends any[] \u003e(fun: T, options?: UseHttpOptions\u003cT, K, D, C\u003e): UseHttpReturn\u003cT, K, D, C\u003e { const data = ref(options?.initialData || {}) as unknown as Ref\u003c UseHttpDataType\u003cT, K\u003e \u003e options = { ...options } const requestOptions: Record\u003cstring, any\u003e = { refreshDepsAction: () =\u003e { run(...params.value) } } const keys = [ 'onSuccess', 'onBefore', 'manual', 'onError', 'onAfter', 'initialData', 'ready' ] const optionKeys = Object.keys(options || {}) as Array\u003c keyof RequestOptions\u003cT, K, D\u003e \u003e optionKeys.forEach((item) =\u003e { if (!keys.includes(item)) { if (options) { requestOptions[item] = options[item] } } }) const currentCreateQuery = ref([]) as unknown as Ref\u003cC\u003e const { runAsync: rAsync, loading, params, error } = useRequest(fun, { ...requestOptions, defaultParams: options?.defaultParams, manual: true, onSuccess(res) { let result = (res || {}) as UseHttpDataSource\u003cT\u003e \u0026 Record\u003cstring, any\u003e if (options?.dataSourceKey) { const dataSourceKey = (options?.dataSourceKey || '').split('.') || [] dataSourceKey.forEach((item) =\u003e { result = result[item] }) } data.value = result as UseHttpDataType\u003cT, K\u003e if (options?.onSuccess) { options.onSuccess(data, [...params.value, ...currentCreateQuery.value]) } }, onError(error) { const err = error as unknown as YxResponse\u003cany\u003e if (options?.onError) { options.onError(err, ...params.value, ...currentCreateQuery.value) } }, onAfter() { if (options?.onAfter) { options.onAfter(...params.value, ...currentCreateQuery.value) } } }) const beforeCallBack = (): | [...UseHttpServiceParams\u003cT\u003e] | boolean | undefined | Promise\u003c[...UseHttpServiceParams\u003cT\u003e] | boolean\u003e | void =\u003e { if (options?.onBefore) { return options.onBefore(...params.value, ...currentCreateQuery.value) } else { return true } } const runAsync = (...query: D): any =\u003e { if (loading.value) { return } const onBeforeResult = beforeCallBack() const resType = otherUtil.getPrototypeType(onBeforeResult) if (resType === 'Promise') { ;(onBeforeResult as Promise\u003c[...UseHttpServiceParams\u003cT\u003e] | boolean\u003e).then( (res) =\u003e { const type = typeof res if (type === 'boolean' \u0026\u0026 !onBeforeResult) { return } if (Array.isArray(res)) { query = res } return rAsync(...(query || params.value)) } ) return } if (resType === 'Boolean' \u0026\u0026 !onBeforeResult) { return } if (resType === 'Array') { query = onBeforeResult as D } return rAsync(...(query || params.value)) } const run = (...query: D): void =\u003e { runAsync(...query) } if (!options?.manual) { run(...params.value) } const refresh = () =\u003e { run(...params.value) } const refreshAsync = () =\u003e { return runAsync(...params.value) } const runWithControl = (...controls: C) =\u003e { currentCreateQuery.value = controls let query = params.value if (options?.onControl) { query = options.onControl(params.value, ...controls) params.value = query } run(...query) } const runWithControlAsync = (...controls: C) =\u003e { let query = params.value currentCreateQuery.value = controls if (options?.onControl) { query = options.onControl(params.value, ...controls) params.value = query } return runAsync(...query) } return { run, loading, runAsync, data, params, error, refresh, refreshAsync, runWithControl, runWithControlAsync } } export default useHttp 未完待续 ","description":"记录一些自己用到的类型体操，不定时更新","tags":["typescript","ts类型体操","useHttp","vue-request","vue3"],"title":"记录一些TS类型体操","uri":"/guohui-blog/posts/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9Bts%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/"}]
